# from gmpy2 import gcdext, invert

# # 公钥指数
# e = 65537

# # 模数
# n = 826280450476795403105390383916395625701073920777162153138597185953056944510888027904354828464602421249363674719063026424044747076553321187265165775178889032794638105579799203345357910166892700405175658568627675449699540840288382597105404255643311670752496397923267416409538484199324051251779098290351314013642933189000153869540797043267546151497242578717464980825955180662199508957183411268811625401646070827084944007483568527240194185553478349118552388947992831458170444492412952312967110446929914832061366940165718329077289379496793520793044453012845571593091239615903167358140251268988719634075550032402744471298472559374963794796831888972573597223883502207025864412727194467531305956804869282127211781893423868568924921460804452906287133831167209340798856323714333552031073990953099946860260440120550744737264831895097569281340675979651355169393606387485601024283179141075124116079680183641040638005340147490312370291020282845417263785200481799143148652902589069064306494803532124234850362800892646823909347208346956741220877224626765444423081432186871792825772139369254830825377015531518313838382717867736340509229694011716101360463757629023320658921011843627332643744464724204771008866440681008984222122706436344770910544932757

# # 密文
# c = 95272795986475189505518980251137003509292621140166383887854853863720692420204142448424074834657149326853553097626486371206617513769930277580823116437975487148956107509247564965652417450550680181691869432067892028368985007229633943149091684419834136214793476910417359537696632874045272326665036717324623992885

# # 分解n
# p = 11387480584909854985125335848240384226653929942757756384489381242206157197986555243995335158328781970310603060671486688856263776452654268043936036556215243
# q = 12972222875218086547425818961477257915105515705982283726851833508079600460542479267972050216838604649742870515200462359007315431848784163790312424462439629

# # 计算欧拉函数
# phi = (p - 1) * (q - 1)

# # 计算私钥指数
# d = invert(e, phi)

# # 解密密文
# m = pow(c, d, n)

# # 转换为明文
# # message = bytes.fromhex(hex(m)[2:].zfill(1024)).decode()
# message = bytes.fromhex(hex(m)[2:].zfill(1024))
# try:
#     message_str = message.decode("utf-8")
#     print(message_str)
# except UnicodeDecodeError as e:
#     print(e)
# # print(message) # Theres_more_than_one_way_to_RSA


from gmpy2 import gcdext, invert

# 公钥指数
e = 65537

# 私钥指数
d = 8191957726161111880866028229950166742224147653136894248088678244548815086744810656765529876284622829884409590596114090872889522887052772791407131880103961

# 模数n的部分位数
n_partial = "826280450476795403105390383916395625701073920777162153138597185953056944510888027904354828464602421249363674719063026424044747076553321187265165775178889032794638105579799203345357910166892700405175658568627675449699540840288382597105404255643311670752496397923267416409538484199324051251779098290351314013642933189000153869540797043267546151497242578717464980825955180662199508957183411268811625401646070827084944007483568527240194185553478349118552388947992831458170444492412952312967110446929914832061366940165718329077289379496793520793044453012845571593091239615903167358140251268988719634075550032402744471298472559374963794796831888972573597223883502207025864412727194467531305956804869282127211781893423868568924921460804452906287133831167209340798856323714333552031073990953099946860260440120550744737264831895097569281340675979651355169393606387485601024283179141075124116079680183641040638005340147490312370291020282845417263785200481799143148652902589069064306494803532124234850362800892646823909347208346956741220877224626765444423081432186871792825772139369254830825377015531518313838382717867736340509229694011716101360463757629023320658921011843627332643744464724204771008866440681008984222122706436344770910544932757"

# 计算ed - 1 mod phi(n)
k = e * d - 1

# 尝试不同的因子g，直到找到满足条件的g
for g in range(2, e):
    # 计算g^k mod n_partial
    t = pow(g, k, int(n_partial))

    # 如果t不等于1，则说明找到了一个可能的因子
    if t != 1:
        # 计算t - 1和n_partial的最大公约数，得到一个可能的因子p或者q
        p = gcdext(t - 1, int(n_partial))[0]

        # 如果p是正数且能整除n_partial，则说明找到了一个正确的因子p
        if p > 0 and int(n_partial) % p == 0:
            # 计算另一个因子q
            q = int(n_partial) // p

            # 计算完整的模数n
            n = p * q

            # 输出结果
            print("p =", p)
            print("q =", q)
            print("n =", n)
            break

# 输出：
# p = 11387480584909854985125335848240384226653929942757756384489381242206157197986555243995335158328781970310603060671486688856263776452654268043936036556215243
# q = 12972222875218086547425818961477257915105515705982283726851833508079600460542479267972050216838604649742870515200462359007315431848784163790312424462439629
# n = 826280450476795403105390383916395625701073920777162153138597185953056944510
